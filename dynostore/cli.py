import argparse
import os
import sys
import logging
from pathlib import Path
from dynostore.client import Client
from logging.handlers import RotatingFileHandler

LOG_LEVEL = os.getenv("LOG_LEVEL", "DEBUG").upper()

LOG_DIR = os.getenv("LOG_DIR", "./logs")
LOG_FILE = os.path.join(LOG_DIR, os.getenv("LOG_FILE", "dynostore.log"))
LOG_LEVEL = os.getenv("LOG_LEVEL", "DEBUG").upper()
CONSOLE_LEVEL = os.getenv("LOG_CONSOLE_LEVEL", "INFO").upper()
FILE_LEVEL = os.getenv("LOG_FILE_LEVEL", LOG_LEVEL)

os.makedirs(LOG_DIR, exist_ok=True)

fmt = logging.Formatter("%(asctime)s,%(levelname)s,%(name)s,%(message)s")

root = logging.getLogger()
root.setLevel(LOG_LEVEL)

# Console
ch = logging.StreamHandler()
ch.setLevel(CONSOLE_LEVEL)
ch.setFormatter(fmt)
root.addHandler(ch)

# Rotating file (50 MB, keep 10 backups)
fh = RotatingFileHandler(LOG_FILE, maxBytes=50 * 1024 * 1024, backupCount=10, encoding="utf-8")
fh.setLevel(FILE_LEVEL)
fh.setFormatter(fmt)
root.addHandler(fh)

logger = logging.getLogger(__name__)

def _log(operation: str, key: str, phase: str, status: str, msg: str = ""):
    # Format: SERVICE, OPERATION, OBJECTKEY, START/END, Status, MSG
    logger.debug(f"CLI,{operation},{key},{phase},{status},{msg}")


def main():
    parser = argparse.ArgumentParser(description='DynoStore CLI Client')
    parser.add_argument('--server', required=True,
                        help='Metadata server address (e.g., 127.0.0.1:5000)')

    subparsers = parser.add_subparsers(dest='command', required=True)

    # PUT
    put_parser = subparsers.add_parser('put', help='Upload data to DynoStore')
    put_parser.add_argument('file', help='Path to the file to upload')
    put_parser.add_argument('--catalog', required=True, help='Catalog name')
    put_parser.add_argument('--key', help='Key to use (default: generated UUID)')
    put_parser.add_argument('--encrypt', action='store_true', help='Encrypt the data')
    put_parser.add_argument('--resiliency', type=int, default=1, help='Resiliency level')
    put_parser.add_argument('--recursive', action='store_true', help='Recursively upload directories')

    # GET
    get_parser = subparsers.add_parser('get', help='Download data from DynoStore')
    get_parser.add_argument('key', help='Key of the object to download')
    get_parser.add_argument('--output', help='Output file to write to (default: stdout)')

    # GET Catalog
    get_catalog_parser = subparsers.add_parser('get_catalog', help='Get all objects in a catalog')
    get_catalog_parser.add_argument('catalog', help='Catalog name to retrieve objects from')
    get_catalog_parser.add_argument('output', help='Output directory to write the catalog to')

    # EXISTS
    exists_parser = subparsers.add_parser('exists', help='Check if object exists')
    exists_parser.add_argument('key', help='Key to check')

    # EVICT
    evict_parser = subparsers.add_parser('evict', help='Remove object from store')
    evict_parser.add_argument('key', help='Key to delete')

    args = parser.parse_args()

    # Default logging setup (caller can override)
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s,%(levelname)s,%(name)s,%(message)s",
    )

    client = Client(metadata_server=args.server)

    try:
        if args.command == 'put':
            _log("PUT", args.key or "-", "START", "RUN",
                 f"file={args.file};catalog={args.catalog};recursive={args.recursive};encrypt={args.encrypt};resiliency={args.resiliency}")

            if args.recursive:
                if not os.path.isdir(args.file):
                    _log("PUT", args.key or "-", "END", "ERROR", f"not_a_directory;path={args.file}")
                    return 1

                dir_path = Path(args.file)
                file_paths = [str(f) for f in dir_path.iterdir() if f.is_file()]

                for filepath in file_paths:
                    _log("PUT_FILE", "-", "START", "RUN", f"path={filepath}")
                    with open(filepath, 'rb') as f:
                        data = f.read()
                    result = client.put(
                        data=data,
                        catalog=args.catalog,
                        is_encrypted=args.encrypt,
                        resiliency=args.resiliency,
                        name=os.path.basename(filepath),
                        key=args.key  # may be None -> generated by Client
                    )
                    obj_key = (result or {}).get("key_object", args.key or "-")
                    _log("PUT_FILE", obj_key, "END", "SUCCESS", f"path={filepath};result={result}")
            else:
                with open(args.file, 'rb') as f:
                    data = f.read()
                result = client.put(
                    data=data,
                    catalog=args.catalog,
                    is_encrypted=args.encrypt,
                    resiliency=args.resiliency,
                    key=args.key
                )
                obj_key = (result or {}).get("key_object", args.key or "-")
                _log("PUT", obj_key, "END", "SUCCESS", f"file={args.file};result={result}")

        elif args.command == 'get':
            _log("GET", args.key, "START", "RUN", f"output={args.output or 'stdout'}")
            data = client.get(args.key)
            if data is not None:
                if args.output:
                    with open(args.output, 'wb') as f:
                        f.write(data)
                    _log("GET", args.key, "END", "SUCCESS", f"output={args.output};bytes={len(data)}")
                else:
                    # no prints by request; log a small preview
                    preview = repr(data[:80])
                    _log("GET", args.key, "END", "SUCCESS", f"stdout_preview={preview};bytes={len(data)}")
            else:
                _log("GET", args.key, "END", "ERROR", "null_data")

        elif args.command == 'get_catalog':
            _log("GET_CATALOG", args.catalog, "START", "RUN", f"output_dir={args.output}")
            paths = client.get_files_in_catalog(args.catalog, output_dir=args.output)
            _log("GET_CATALOG", args.catalog, "END", "SUCCESS", f"written_count={len(paths)}")

        elif args.command == 'exists':
            _log("EXISTS", args.key, "START", "RUN", "")
            exists = client.exists(args.key)
            _log("EXISTS", args.key, "END", "SUCCESS", f"exists={exists}")

        elif args.command == 'evict':
            _log("EVICT", args.key, "START", "RUN", "")
            client.evict(args.key)
            _log("EVICT", args.key, "END", "SUCCESS", "")

    except Exception as e:
        _log(args.command.upper(), getattr(args, "key", "-") or "-", "END", "ERROR", f"msg={e}")
        return 1

    return 0


if __name__ == '__main__':
    sys.exit(main())
